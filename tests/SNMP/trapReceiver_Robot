# snmp_trap_listener.py
from pysnmp.carrier.asyncio.dispatch import AsyncioDispatcher
from pysnmp.carrier.asyncio.dgram import udp #, udp6 # Comentado udp6 para simplificar, puedes añadirlo si lo necesitas
from pyasn1.codec.ber import decoder
from pysnmp.proto import api
from pysnmp.smi import builder, view, compiler, rfc1902
from datetime import datetime, timezone
import threading
import time
import logging
from collections import deque

# Configuración de logging básico
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

class SnmpTrapListener:
    ROBOT_LIBRARY_SCOPE = 'TEST SUITE' # O 'GLOBAL' si prefieres una única instancia para todo

    def __init__(self):
        self._transport_dispatcher = None
        self._mib_builder = None
        self._mib_view_controller = None
        self._received_traps = deque() # Usamos deque para eficiencia en appends/pops
        self._trap_filters = [] # Lista para almacenar los filtros
        self._listener_thread = None
        self._stop_event = threading.Event()
        self._lock = threading.Lock() # Para proteger el acceso a received_traps y filters

    def _initialize_mib_controller(self, mib_dirs_string):
        """Inicializa los controladores MIB."""
        self._mib_builder = builder.MibBuilder()
        self._mib_view_controller = view.MibViewController(self._mib_builder)
        
        if mib_dirs_string:
            mib_dirs = [d.strip() for d in mib_dirs_string.split(',')]
            compiler.add_mib_compiler(self._mib_builder, sources=mib_dirs)
        else:
            # Añadir fuentes por defecto o MIBs estándar si es necesario
            # compiler.add_mib_compiler(self._mib_builder, sources=['/opt/pysnmp_mibs']) # Ejemplo
            logging.info("No MIB directories provided, using default MIB compiler setup.")


    def load_mibs(self, *mib_modules):
        """
        Carga los módulos MIB especificados.
        Ejemplo en Robot Framework:
        | Load Mibs | DIMAT-BASE-MIB | DIMAT-TPU1C-MIB |
        """
        if not self._mib_builder:
            raise RuntimeError("El controlador MIB no ha sido inicializado. Llama a 'Start Trap Listener' primero.")
        try:
            self._mib_builder.load_modules(*mib_modules)
            logging.info(f"MIBs cargadas: {', '.join(mib_modules)}")
        except Exception as e:
            logging.error(f"Error al cargar MIBs {mib_modules}: {e}")
            raise

    def _callback(self, transportDispatcher, transportDomain, transportAddress, wholeMsg):
        """Callback para procesar mensajes SNMP recibidos."""
        logging.debug(f"Callback received data from {transportAddress}")
        while wholeMsg:
            msg_ver = int(api.decodeMessageVersion(wholeMsg))
            if msg_ver in api.PROTOCOL_MODULES:
                p_mod = api.PROTOCOL_MODULES[msg_ver]
            else:
                logging.warning(f"Versión SNMP no soportada {msg_ver} desde {transportAddress}")
                return

            req_msg, wholeMsg = decoder.decode(wholeMsg, asn1Spec=p_mod.Message())
            
            logging.info(f"Notificación desde {transportAddress[0]}:{transportAddress[1]}")

            req_pdu = p_mod.apiMessage.get_pdu(req_msg)
            if not req_pdu.isSameTypeWith(p_mod.TrapPDU()) and not req_pdu.isSameTypeWith(p_mod.InformRequestPDU()): # También para Inform
                logging.warning(f"PDU no es Trap/Inform: {req_pdu.prettyPrint()} desde {transportAddress}")
                return

            var_binds_list = []
            processed_var_binds = {}

            if msg_ver == api.SNMP_VERSION_1:
                var_binds_raw = p_mod.apiTrapPDU.get_varbinds(req_pdu)
                # Podrías extraer enterprise, agent_address, etc. aquí si es necesario
            else:
                var_binds_raw = p_mod.apiPDU.get_varbinds(req_pdu)

            try:
                # Asegúrate de que mib_view_controller está disponible
                if not self._mib_view_controller:
                    logging.error("MibViewController no está inicializado en el callback.")
                    # Intenta inicializarlo aquí si tiene sentido o simplemente no resuelvas
                    # Esto es una contingencia, debería estar siempre inicializado
                    var_binds_resolved = var_binds_raw 
                else:
                    var_binds_resolved = [
                        rfc1902.ObjectType(rfc1902.ObjectIdentity(x[0]), x[1]).resolve_with_mib(self._mib_view_controller)
                        for x in var_binds_raw
                    ]
            except Exception as e:
                logging.error(f"Error al resolver VarBinds con MIBs: {e}")
                # Continuar con los VarBinds sin resolver o parcialmente resueltos
                var_binds_resolved = var_binds_raw # O manejar de otra forma

            for oid_obj, val_obj in var_binds_resolved:
                oid_str = oid_obj.prettyPrint()
                val_str = val_obj.prettyPrint()
                # print(oid_str, val_str) # Para depuración, puedes quitarlo después
                
                # Aplicar transformaciones especiales
                if "tpu1cNotifyTimeSecsUtc" in oid_str:
                    try:
                        val_transformed = datetime.fromtimestamp(int(val_obj), tz=timezone.utc).isoformat()
                        val_str = val_transformed # Actualiza val_str para el almacenamiento
                    except ValueError:
                        logging.warning(f"No se pudo convertir el timestamp para {oid_str}: {val_obj}")
                        # val_str permanece como el prettyPrint original
                elif "1.3.6.1.4.1.6346.1.8" in val_str: # Asumo que te refieres al valor y no al OID aquí
                    try:
                        # Obtener la etiqueta del nodo si es posible
                        node_location = self._mib_view_controller.getNodeLocation(val_obj)
                        if node_location and len(node_location) > 1:
                             val_transformed = f"Notification Type {node_location[1]}" # Usar el segundo elemento (nombre)
                             val_str = val_transformed
                    except Exception as e:
                        logging.warning(f"No se pudo obtener la etiqueta para {val_str} (OID: {oid_str}): {e}")
                
                var_binds_list.append({'oid': oid_str, 'value': val_str, 'raw_value': val_obj})
                processed_var_binds[oid_str] = val_str # Para filtrado más simple por OID->valor

            trap_data = {
                'source_ip': transportAddress[0],
                'source_port': transportAddress[1],
                'timestamp': datetime.now(timezone.utc).isoformat(),
                'varbinds_list': var_binds_list, # Lista de diccionarios
                'varbinds_dict': processed_var_binds # Diccionario OID:valor
            }
            
            with self._lock:
                self._received_traps.append(trap_data)
            logging.info(f"Trap almacenado: {trap_data['source_ip']}, {len(trap_data['varbinds_list'])} VarBinds")

        return wholeMsg # Para pysnmp, para continuar procesando si hay más mensajes en el datagrama

    def start_trap_listener(self, listen_ip="0.0.0.0", listen_port=162, mib_dirs_string=""):
        """
        Inicia el listener de traps SNMP en un hilo separado.
        `mib_dirs_string` es una cadena de rutas a directorios MIB separadas por comas, ej: "file:///path/to/mibs1,file:///path/to/mibs2"
        """
        if self._listener_thread and self._listener_thread.is_alive():
            logging.info("El listener ya está en ejecución.")
            return

        self._stop_event.clear()
        with self._lock:
            self._received_traps.clear() # Limpiar traps de ejecuciones previas
            self._trap_filters.clear()   # Limpiar filtros de ejecuciones previas

        self._initialize_mib_controller(mib_dirs_string)
        # Es importante cargar las MIBs *después* de inicializar el mib_controller y *antes* de iniciar el dispatcher
        # Las MIBs deben cargarse usando la keyword `Load Mibs` después de `Start Trap Listener`

        self._transport_dispatcher = AsyncioDispatcher()
        self._transport_dispatcher.register_recv_callback(self._callback)

        # UDP/IPv4
        try:
            self._transport_dispatcher.register_transport(
                udp.DOMAIN_NAME, udp.UdpAsyncioTransport().open_server_mode((listen_ip, int(listen_port)))
            )
            logging.info(f"Listener de traps SNMP iniciado en {listen_ip}:{listen_port}")
        except Exception as e:
            logging.error(f"Error al registrar el transporte UDP/IPv4 en {listen_ip}:{listen_port}: {e}")
            raise RuntimeError(f"Fallo al iniciar el listener: {e}")

        # UDP/IPv6 (opcional, descomentar si es necesario)
        # try:
        #     self._transport_dispatcher.registerTransport(
        #         udp6.domainName, udp6.Udp6AsyncioTransport().openServerMode(('::1', int(listen_port)))
        #     )
        #     logging.info(f"Listener de traps SNMP (IPv6) iniciado en ::1:{listen_port}")
        # except Exception as e:
        #     logging.warning(f"No se pudo iniciar el listener IPv6 (esto puede ser normal si IPv6 no está disponible): {e}")


        self._listener_thread = threading.Thread(target=self._run_dispatcher_loop, daemon=True)
        self._listener_thread.start()
        
        # Dar un pequeño tiempo para que el hilo arranque
        time.sleep(0.1)
        if not self._listener_thread.is_alive():
             raise RuntimeError("El hilo del listener no pudo iniciarse.")
        logging.info("Hilo del dispatcher iniciado.")


    def _run_dispatcher_loop(self):
        """Bucle para ejecutar el dispatcher y manejar el evento de parada."""
        if not self._transport_dispatcher:
            logging.error("Transport dispatcher no está inicializado en _run_dispatcher_loop.")
            return
            
        self._transport_dispatcher.job_started(1) # Indicar que hay un trabajo activo
        try:
            self._transport_dispatcher.run_dispatcher() 
        except Exception as e:
            logging.error(f"Error en el bucle del dispatcher: {e}")
        finally:
            self._transport_dispatcher.jobFinished(1) # Indicar que el trabajo ha terminado
            # No cierres el dispatcher aquí si quieres poder reiniciarlo.
            # El cierre se maneja en stop_trap_listener
            logging.info("Bucle del dispatcher finalizado.")


    def stop_trap_listener(self):
        """Detiene el listener de traps SNMP."""
        if not self._listener_thread or not self._listener_thread.is_alive():
            logging.info("El listener no está en ejecución.")
            return

        logging.info("Deteniendo el listener de traps...")
        self._stop_event.set()
        
        if self._transport_dispatcher:
            # Esto podría causar que runDispatcher salga si está esperando I/O
            self._transport_dispatcher.close_dispatcher() 
            # Esperar un poco para que el closeDispatcher tenga efecto y el bucle termine
            time.sleep(0.1) 

        self._listener_thread.join(timeout=5.0) # Esperar a que el hilo termine

        if self._listener_thread.is_alive():
            logging.warning("El hilo del listener no terminó correctamente.")
        else:
            logging.info("Listener de traps detenido y hilo terminado.")
        
        self._listener_thread = None
        self._transport_dispatcher = None # Liberar el dispatcher

    def add_trap_filter(self, oid, value=None, condition='equals'):
        """
        Añade un filtro para los traps.
        - oid: El OID a buscar en los VarBinds.
        - value: El valor esperado para ese OID (opcional).
        - condition: 'equals', 'contains', 'startswith', 'endswith', 'regex' (si 'value' es proporcionado).
        
        Ejemplo en Robot Framework:
        | Add Trap Filter | 1.3.6.1.2.1.1.5.0 | server_name_A    | condition=contains |
        | Add Trap Filter | 1.3.6.1.6.3.1.1.4.1.0 |                                | # Solo verificar presencia de OID |
        """
        with self._lock:
            self._trap_filters.append({'oid': oid, 'value': value, 'condition': condition.lower()})
        logging.info(f"Filtro añadido: OID={oid}, Value={value}, Condition={condition}")

    def clear_trap_filters(self):
        """Limpia todos los filtros de traps definidos."""
        with self._lock:
            self._trap_filters.clear()
        logging.info("Todos los filtros de traps han sido eliminados.")

    def clear_received_traps(self):
        """Limpia la cola de traps recibidos."""
        with self._lock:
            self._received_traps.clear()
        logging.info("Cola de traps recibidos limpiada.")

    def _check_condition(self, actual_value, expected_value, condition):
        if expected_value is None: # Si no se espera valor, la condición de OID ya se cumplió
            return True
        if actual_value is None: # No hay valor real para comparar
            return False
            
        actual_value_str = str(actual_value)
        expected_value_str = str(expected_value)

        if condition == 'equals':
            return actual_value_str == expected_value_str
        elif condition == 'contains':
            return expected_value_str in actual_value_str
        elif condition == 'startswith':
            return actual_value_str.startswith(expected_value_str)
        elif condition == 'endswith':
            return actual_value_str.endswith(expected_value_str)
        elif condition == 'regex':
            import re
            return bool(re.search(expected_value_str, actual_value_str))
        else:
            logging.warning(f"Condición de filtro desconocida: {condition}")
            return False

    def _trap_matches_filters(self, trap_data):
        """Verifica si un trap coincide con TODOS los filtros definidos."""
        if not self._trap_filters: # Si no hay filtros, cualquier trap es un "match"
            return True

        for f in self._trap_filters:
            oid_to_find = f['oid']
            expected_value = f['value']
            condition = f['condition']
            
            found_oid_in_trap = False
            for varbind in trap_data['varbinds_list']:
                if varbind['oid'] == oid_to_find:
                    found_oid_in_trap = True
                    # Si el filtro incluye una condición de valor, verificarla
                    if expected_value is not None:
                        if self._check_condition(varbind['value'], expected_value, condition):
                            # Este VarBind cumple este filtro específico. Pasa al siguiente filtro.
                            break 
                        else:
                            # El valor del VarBind no cumple. Este filtro falla para este trap.
                            return False
                    else:
                        # Solo se requería la presencia del OID, y se encontró. Pasa al siguiente filtro.
                        break 
            
            if not found_oid_in_trap:
                # El OID requerido por este filtro no está en el trap. Este filtro falla.
                return False
        
        # Si todos los filtros fueron satisfechos por el trap
        return True

    def wait_for_trap(self, timeout=30, consume_trap=True):
        """
        Espera a que llegue un trap que coincida con los filtros definidos.
        Devuelve el primer trap coincidente o None si se agota el tiempo.
        - timeout: Tiempo máximo de espera en segundos.
        - consume_trap: Si es True (por defecto), el trap coincidente se elimina de la cola.
        """
        end_time = time.monotonic() + float(timeout)
        logging.info(f"Esperando trap con filtros (timeout={timeout}s): {self._trap_filters}")
        
        while time.monotonic() < end_time:
            with self._lock:
                for i, trap_data in enumerate(self._received_traps):
                    if self._trap_matches_filters(trap_data):
                        logging.info(f"Trap coincidente encontrado: {trap_data['source_ip']}")
                        if consume_trap:
                            # No podemos hacer pop(i) directamente en deque de forma eficiente
                            # Reconstruimos la deque sin el elemento, o rotamos y hacemos popleft
                            # Para simplificar, si consume_trap es común, mejor iterar y añadir a otra lista
                            # o encontrarlo, extraerlo y volver a crear la deque.
                            # Opción simple pero no la más eficiente para deques largas:
                            matched_trap = self._received_traps[i]
                            temp_list = list(self._received_traps)
                            temp_list.pop(i)
                            self._received_traps = deque(temp_list)
                            return matched_trap
                        return trap_data
            time.sleep(0.2) # Pequeña pausa para no consumir CPU excesivamente

        logging.info(f"Timeout esperando trap. No se encontró ningún trap coincidente con los filtros.")
        return None

    def get_all_received_traps(self):
        """Devuelve una lista de todos los traps recibidos (copia)."""
        with self._lock:
            return list(self._received_traps)

# Para probar el script directamente (opcional)
if __name__ == '__main__':
    print("Iniciando listener de traps SNMP para prueba...")
    # Rutas MIB de ejemplo, ajusta según tu sistema.
    # En Windows: "file:///C:/Users/tu_usuario/Documents/SNMP/compiled_mibs"
    # En Linux: "file:///usr/share/snmp/mibs", "/opt/pysnmp_mibs"
    # Asegúrate que las MIBs compiladas en .py (o .pyc/.pyo) estén en estas rutas.
    # O que sean MIBs en formato ASN.1 si pysmi las puede encontrar y compilar.
    # Para usar MIBs compiladas, la ruta debe ser como 'file:///...'
    mib_path = "file:///C:/Users/sergio.bret/Documents/SNMP/compiled_mibs" 
    
    listener = SnmpTrapListener()
    try:
        listener.start_trap_listener(listen_ip="10.212.42.4", listen_port=1620, mib_dirs_string=mib_path)
        # Cargar MIBs *después* de iniciar el listener si se usa la estructura de clase
        listener.load_mibs("DIMAT-BASE-MIB", "DIMAT-TPU1C-MIB") # Nombres de módulos MIB, no archivos .py

        # print("Listener iniciado. Esperando traps en 127.0.0.1:16200...")
        # print("Puedes enviar un trap con, por ejemplo:")
        # print("$ snmptrap -v2c -c public 127.0.0.1:16200 '' 1.3.6.1.6.3.1.1.5.1 1.3.6.1.2.1.1.5.0 s 'TestServer' 1.3.6.1.4.1.20408.1.1 s 'TestValue'")

        # Ejemplo de filtro:
        # listener.add_trap_filter(oid="1.3.6.1.2.1.1.5.0", value="TestServer", condition="equals")
        # listener.add_trap_filter(oid="1.3.6.1.4.1.20408.1.1", value="TestValue") # Equals por defecto

        trap = listener.wait_for_trap(timeout=60)

        if trap:
            print("\nTRAP RECIBIDO Y FILTRADO:")
            print(trap)
            # import json
            # print(json.dumps(trap, indent=2))
        else:
            print("\nNo se recibió ningún trap coincidente en 60 segundos.")

    except KeyboardInterrupt:
        print("Interrupción por teclado recibida.")
    except Exception as e:
        print(f"Error: {e}")
    finally:
        print("Deteniendo listener...")
        listener.stop_trap_listener()
        print("Listener detenido.")